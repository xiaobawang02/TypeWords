<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>TypeWords æ•°æ®è¿ç§»</title>
    <style>
        body {
            font-family: sans-serif;
            padding: 20px;
        }

        button {
            padding: 10px 20px;
            font-size: 16px;
        }

        pre {
            background: #f7f7f7;
            padding: 10px;
            border-radius: 4px;
        }
    </style>
</head>
<body>
<h2>TypeWords æ•°æ®è¿ç§»ï¼ˆæ—§åŸŸåï¼‰</h2>
<p>ç­‰å¾…æ–°åŸŸåå‘é€è¿ç§»æŒ‡ä»¤ ...</p>
<pre id="log"></pre>

<script>
  function log(msg) {
    console.log(msg);
    document.getElementById('log').textContent += msg + "\n";
  }

  let dbReadyPromise = null;
  let name = 'keyval-store';
  let keys = [
    'type-words-app-version',
    'typing-word-dict',
    'typing-word-setting',
    'typing-word-files'
  ]

  function openDB(dbName, keys) {
    if (dbReadyPromise) return dbReadyPromise;

    dbReadyPromise = new Promise((resolve, reject) => {
      const request = indexedDB.open(dbName, 1);

      request.onupgradeneeded = (event) => {
        const db = event.target.result;

        keys.forEach((name) => {
          if (!db.objectStoreNames.contains(name)) {
            db.createObjectStore(name);
          }
        });
      };

      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });

    return dbReadyPromise;
  }

  openDB(name, keys)

  // --- localStorage è¯»å– ---
  function readLocalStorageKeys(keys) {
    const out = {};
    keys.forEach(k => {
      out[k] = localStorage.getItem(k);
    });
    return out;
  }

  // --- IndexedDBï¼ˆå…¼å®¹ idb-keyvalï¼‰è¯»å– ---
  function readIndexedDBCompatible(dbName, keys) {
    return new Promise(async (resolve) => {
      const db = await openDB(dbName, keys);
      const stores = Array.from(db.objectStoreNames);

      if (stores.length === 0) {
        db.close();
        tryOpenKeyvalDefault();
        return;
      }

      if (stores.length === 1 && stores[0] === 'keyval') {
        readFromKeyvalDB(db).then(result => {
          db.close();
          resolve(result);
        });
      } else {
        readFromMultipleStores(db, stores).then(result => {
          db.close();
          resolve(result);
        });
      }

      function tryOpenKeyvalDefault() {
        const req = indexedDB.open('keyval');
        req.onerror = () => resolve({indexedDB: {}, reason: 'no-db'});
        req.onsuccess = function () {
          const db2 = req.result;
          readFromKeyvalDB(db2).then(result => {
            db2.close();
            resolve(result);
          });
        };
      }

      function readFromKeyvalDB(db) {
        return new Promise((res) => {
          const tx = db.transaction('keyval', 'readonly');
          const store = tx.objectStore('keyval');

          const out = {};
          let finished = 0;
          keys.forEach(k => {
            const r = store.get(k);
            r.onsuccess = () => {
              out[k] = r.result ?? null;
              if (++finished === keys.length) res({indexedDB: out});
            };
            r.onerror = () => {
              out[k] = null;
              if (++finished === keys.length) res({indexedDB: out});
            };
          });
        });
      }

      function readFromMultipleStores(db, stores) {
        return new Promise(res => {
          const result = {};
          let count = 0;
          stores.forEach(storeName => {
            try {
              const tx = db.transaction(storeName, 'readonly');
              const store = tx.objectStore(storeName);
              const req = store.getAll();

              req.onsuccess = () => {
                result[storeName] = req.result;
                if (++count === stores.length) res({indexedDB: result});
              };
              req.onerror = () => {
                result[storeName] = [];
                if (++count === stores.length) res({indexedDB: result});
              };
            } catch {
              result[storeName] = [];
              if (++count === stores.length) res({indexedDB: result});
            }
          });
        });
      }
    });
  }

  async function readAllStorageForMigration() {
    const local = readLocalStorageKeys(['PracticeSaveWord', 'PracticeSaveArticle']);
    const indexed = await readIndexedDBCompatible(name, keys);
    return {localStorage: local, indexedDB: indexed.indexedDB ?? {}};
  }

  // =====================
  // ğŸ”¥ è‡ªåŠ¨ç›‘å¬è¿ç§»æŒ‡ä»¤
  // =====================
  window.addEventListener('message', async (event) => {
    if (event.data?.type === 'REQUEST_MIGRATION_DATA') {
      log('æ”¶åˆ°è¿ç§»æŒ‡ä»¤ï¼Œå¼€å§‹è¯»å–æœ¬åœ°æ•°æ®...');
      const data = await readAllStorageForMigration();
      log('è¯»å–å®Œæˆï¼Œå¼€å§‹å‘é€æ•°æ®åˆ°æ–°åŸŸå');

      event.source.postMessage({type: 'MIGRATE_DATA', payload: data}, event.origin);

      log('å·²å‘é€è¿ç§»æ•°æ®');
    }
  });
</script>
</body>
</html>